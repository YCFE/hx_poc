{"version":3,"sources":["../../../src/type/component/component.js"],"names":["ComponentDecoratorGenerator","metaKeys","generateOptionFromMeta","meta","name","forEach","k","generateKeysFromProto","proto","protoKeys","Object","getOwnPropertyNames","internalKeys","normalKeys","isInternalKey","push","String","prototype","substr","call","collectInternalProp","key","options","lifecycleHooks","config","_lifecycleHooks","lifecycHookMap","collectNormalProp","descriptor","getOwnPropertyDescriptor","value","Array","isArray","methods","get","set","computed","connectFunc","connectFuncExec","hasMapExec","mapExec","decorate","cls","wrapOptions","func"],"mappings":"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","file":"component.js","sourcesContent":["import Vue from 'vue';\nimport { PropertyProcessor, modifyProperty } from '../property/index.js';\nimport { warn, hasOwn, makeMap } from '../utils';\nimport { hasConnectProperty, generateConnectFunc } from '../connect';\n\nconst metaKeys = ['props', 'computed', 'watch'];\n\nfunction generateOptionFromMeta(meta = {}, name) {\n\n  meta.name = meta.name || name;\n  metaKeys.forEach((k) => {\n    if ( !hasOwn(meta, k) ) {\n      meta[k] = {};\n    }\n  });\n\n  return meta;\n}\n\nfunction generateKeysFromProto(proto) {\n  const protoKeys = Object.getOwnPropertyNames(proto)\n  const internalKeys = [];\n  const normalKeys = [];\n\n  protoKeys.forEach((k) => {\n    if ( k === 'constructor' ) {\n      return;\n      //throw new Error('Component Does not support constructor, if you want to do something when constructing, try [beforeCreate] hook')\n    }\n\n    if ( isInternalKey(k) ) {\n      internalKeys.push(k);\n    }\n    else {\n      normalKeys.push(k);\n    }\n\n  });\n\n  return {\n    internalKeys,\n    normalKeys\n  };\n\n  function isInternalKey(k) {\n    return String.prototype.substr.call(k,0,2) === '$$';\n  }\n}\n\nfunction collectInternalProp(proto, key, options) {\n  \"use strict\";\n  PropertyProcessor(proto, key, options)\n}\n\nconst lifecycleHooks = Vue.config._lifecycleHooks;\n// makeMap\nconst lifecycHookMap = makeMap(lifecycleHooks, true);\n\nfunction collectNormalProp(proto, key, options) {\n  let descriptor = Object.getOwnPropertyDescriptor(proto, key);\n\n  if (!descriptor) return;\n\n  const lifecycleHooks = Vue.config._lifecycleHooks;\n\n  // 如果是 函数\n  if (typeof descriptor.value === 'function' ) {\n    // 如果是在生命周期中\n    if ( lifecycHookMap[key] ) {\n\n      options[key] = options[key] || [];\n      options[key] = Array.isArray(options[key]) ? options[key] : [ options[key] ];\n\n      options[key].push(descriptor.value)\n    }\n    else if ( key === 'render' ) {\n      options[key] = descriptor.value;\n    }\n    // 如果是普通方法\n    else {\n      // 判重\n      options.methods = options.methods || {};\n      if ( options.methods[key] ) {\n        warn(`member method [${key}] has duplicated definitions`);\n      }\n      options.methods[key] = descriptor.value;\n    }\n  }\n  // 考虑computed处理\n  else if ( descriptor.get || descriptor.set ){\n    options.computed[key] = {\n      get: descriptor.get,\n      set: descriptor.set\n    }\n  }\n}\n\nexport function ComponentDecoratorGenerator(meta = {}) {\n\n  // 从meta中读取需要的 \n  // mapStateToProps, mapMethodsToProps, mapMethodsToEvents, mapExec\n  // 交给 connect 生成一个 function\n  // 然后交给 decorate 的return options 里面拼上去\n  // \n  let connectFunc = null;\n  let connectFuncExec = false;\n  let hasMapExec = false;\n  if ( hasConnectProperty(meta) ) { \n\n    connectFuncExec = !!meta.mapExec;\n    hasMapExec = typeof meta.mapExec !== 'undefined';\n    connectFunc = generateConnectFunc(meta);\n  }\n\n  return function decorate(cls) {\n    const proto = cls.prototype;\n\n    // 合并meta数据\n    let options = generateOptionFromMeta(meta, cls['name']);\n\n    const {\n      internalKeys,\n      normalKeys\n    } = generateKeysFromProto(proto);\n\n    // 寻找对应的 prop 处理器进行处理\n    internalKeys.forEach((k) => {\n      collectInternalProp(proto, k, options);\n    });\n\n    // 根据normalKeys 按对应规则收集数据\n    // Lifecycle --> function(特定名称)\n    // Method --> function\n    // Computed --> getter, setter\n    normalKeys.forEach((k) => {\n      collectNormalProp(proto, k, options);\n    });\n\n    // 再执行一次 option modifier\n    modifyProperty(options);\n\n    // 考虑下兼容性问题\n    // 如果有 connectFunc，说明声明了 connectFunc\n    if ( connectFunc ) {\n      // 如果手工指定了 hasMapExec, 按照指定的来\n      if ( hasMapExec ) {\n        // 自动执行connect\n        if ( connectFuncExec ) {\n          options = connectFunc(options);\n        } else {\n          // 不执行，需要挂载到 vue-loader 去识别\n          options['__kylin_connect_function__'] = connectFunc;\n        }\n      } else {\n        // 在没主动指定 mapExec 的情况下，默认行为变更\n        // 自动执行, 考虑到 vue-loader 的影响，配置 挂载 connectFunc 和 options\n        const wrapOptions = connectFunc(options);\n        wrapOptions['__kylin_connect_wrap__'] = {\n          func: connectFunc,\n          options: options\n        }\n        // wrapOptions['__kylin_connect_function_in wrap__'] = connectFunc;\n        // wrapOptions['__kylin_connect_options_in_wrap__'] = options;\n        options = wrapOptions;\n      }\n    } else {\n      // 没声明connectFunc，完全不处理\n    }\n\n    // 需要执行\n    // if ( connectFuncExec ) {\n    //   options = connectFunc(options);\n    // } else {\n    //   options['__kylin_connect_function__'] = connectFunc;\n    // }\n\n    return options;\n  };\n}"]}